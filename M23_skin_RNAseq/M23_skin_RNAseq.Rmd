---
title: "M23_skin_RNAseq"
output: html_document
date: '2022-05-19'
---
## ****
# READ ME:
# This is for post-salmon analysis and plotting
# dir on linux
## ****

# ========================================================
# Linux directory setup
# Import metadata (mapping file)
# ========================================================
```{r}
## Change to location of results directory and samples.csv file
setwd("/workdir/ml2593/RNAseq_skinM23_051922")
base_dir = getwd()
salmon_dir = dir("/workdir/ml2593/RNAseq_skinM23_051922/salmon")

# Create directory for output results
dir.create(file.path(getwd(), 'R_output'), showWarnings = FALSE)

## Import sample and condition file
samples = read.csv(file.path("/workdir/ml2593/RNAseq_skinM23_051922", "M23_skin_map.csv"), header = TRUE, stringsAsFactors=FALSE)
samples$Diet <- factor(samples$Diet)
samples$Gavage <- factor(samples$Gavage)
rownames(samples) <- samples$sample

# remove two bad mapping files
samples <- samples %>%
  filter(!sample == "chow_skin_24") %>%
  filter(!sample == "SLMUTpaa_skin_22")
```

# ========================================================
#Save the entire list of environments objects
# ========================================================
```{r}
# save
save.image(file = "M23_skin_RNAseq.RData")
dir()

#load environment
load("/Users/min-tinglee/Desktop/RNAseq/20220519_skin_M23/M23_skin_RNAseq.RData")
```

# ==============
# Load packages
# ==============
```{r}
library(tximport) 
#tximport package that we use to import Salmon counts
library(tximportData)
library(GenomicFeatures)
library(biomaRt)
library(DESeq2)
library(ggplot2)
library(ggpubr)
library(gplots)
library(ggrepel)
library(tidyverse)
library(RColorBrewer)
library(pheatmap)
library(dplyr)
library(EnhancedVolcano)
library(OTUtable)
library(circlize)
library(ComplexHeatmap)

## packages for Gene set analysis
library(fgsea)
library(org.Hs.eg.db)

## packages for clusterProfiler
library(org.Mm.eg.db)
library(DOSE)
library(pathview)
library(clusterProfiler)
library(AnnotationHub)
library(ensembldb)
#detach("package:ensembldb")
library(enrichplot)
library(ggnewscale)

library(ggvenn)
library(ggupset)
```


# ========================================================
# Make a TxDb object from transcript annotations
# ========================================================
```{r}
## - available as a GFF3 or GTF file
## - can be downloaded from gencode for mouse / human, ensembl for other species

gtf="/workdir/ml2593/RNAseq_skinM23_051922/gencode.vM29.primary_assembly.annotation.gtf"
txdb=makeTxDbFromGFF(gtf,
                     format="gtf",
                     organism="Mus musculus")

# Prepare the annotation file needed to import the Salmon counts: a two-column data frame linking transcript id to gene id.
# We will add the gene symbol in the 3rd for a more comprehensive annotation
# process from the GTF file:

k <- keys(txdb, keytype = "GENEID")
df <- select(txdb, keys = k, keytype = "GENEID", columns = "TXNAME") # need to detach dplyr to run this
#detach("package:dplyr")

tx2gene <- df[, 2:1]
head(tx2gene)



# import salmon quant files and create counts table
# List the quantification files from Salmon: one quant.sf file per sample
# dir is list all files in "~/full_data/counts_salmon" and in any directories inside, that have the pattern "quant.sf". full.names = TRUE means that we want to keep the whole paths
files <- dir("/workdir/ml2593/RNAseq_skinM23_051922/salmon", recursive = TRUE, pattern = "quant.sf", full.names = TRUE)
all(file.exists(files)) # Verify names of files match names in samples.csv, should return True


# files is a vector of file paths. we will name each element of this vector with a simplified corresponding sample name
names(files) <- dir("/workdir/ml2593/RNAseq_skinM23_051922/salmon")

# import data from salmon
txi <- tximport(files, 
                type = "salmon", 
                tx2gene = tx2gene)

# display the first rows of the counts per gene information
head(txi$counts)
colnames(txi$counts)

# check the names of the "slots" of the txi object
names(txi)

## Now to import the data into a DESeq Data Set (dds)
## Verify that sample names and colnames are the same
identical(samples$sample,colnames(txi$counts))

# Create a DESeq2 object based on Salmon per-gene counts
dds <- DESeqDataSetFromTximport(txi,
                                colData = samples, 
                                design = ~Gavage) ## for now the coldata is samples..




```

# ========================================================
# Samples similarity
# Heatmap and PCA
# ========================================================
```{r}
## Set color palette for figures
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

## Perform a rlog transformation on count data (essentially a puts on a log2 scale)
## This helps our data assume a normal distribution and is good to do before these analyses
rld <- rlog(dds, blind=TRUE)

## Setup annotation file to show the conditions on the figures
treat_ann <- samples
rownames(treat_ann) <- treat_ann$sample
treat_ann$sample <- NULL
treat_ann

## =========. SAMPLE TO SAMPLE DISTANCE & CORRELATION HEATMAPS =========. 
## Sample correlation heatmap
corr_samps <- cor(as.matrix(assay(rld))) # Computes pairwise correlations between samples based on gene expression

pdf("R_output/sampleCorr_HM.pdf", width = 12, height = 10)
pheatmap(corr_samps,
         annotation = treat_ann,
         col=colors,
         main="Sample Correlations")
dev.off()


# Sample distance heatmap
sampleDists <- dist(t(assay(rld)))            # Computes Euclidean distance between samples based on gene expression
sampleDistMatrix <- as.matrix(sampleDists)

pdf("R_output/sampleDist_HM.pdf", width = 12, height = 10)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         annotation = treat_ann,
         col=colors,
         main="Sample to Sample Distances")
dev.off()



## Principal Component Analysis
## Separates samples based on variation between sample's gene expression
## Greater variation will affect separation to a greater degree

data_gavage <- plotPCA(rld, intgroup=c("Gavage"), returnData=TRUE)
percentVar_gavage <- round(100 * attr(data_gavage, "percentVar"))

pdf('R_output/PCA_gavage.pdf', width=8, height=6)
ggplot(data_gavage, aes(PC1, PC2, color=Gavage)) +
  geom_point(size=3.5) +
  geom_text_repel(aes(label=name)) +
  #scale_colour_manual(values = c("grey","#fc759d")) +
  theme_bw() +
  xlab(paste0("PC1: ",percentVar_gavage[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar_gavage[2],"% variance")) +
  ggtitle("pca_gavage")
dev.off()
```

# ========================================================
#   Get table to convert names
# ========================================================
```{r}
# identify database need
listEnsembl()  
ensembl <- useEnsembl(biomart = "mouse_strains")
ensembl

## Convert the ensembl gene ID to gene name
## This will require an active internet connection
## Need to change according to species of interest
mart<- useDataset("mmusculus_gene_ensembl", useMart("ensembl"))

ensembl_2_geneName <- getBM(attributes = c("ensembl_gene_id", 
                                           "external_gene_name"),
                            mart = mart)  #if shows error, try multiple times

head(ensembl_2_geneName)
names(ensembl_2_geneName) <- c("GENEID", "geneName")
```

# ========================================================
# Differential expression analysis
# ========================================================
```{r}
## DESeq = fx to calculate DE
## Combines multiple steps from DESeq
dds2 <- DESeq(dds)
dds2

## Write normalized counts to file
normalized.counts <- as.data.frame(counts(dds2, normalized=TRUE ))
rownames(normalized.counts)<-sub("\\.[0-9]*", "", rownames(normalized.counts))
head(normalized.counts)

# Add gene name column
idx <- match( rownames(normalized.counts), ensembl_2_geneName$GENEID )
normalized.counts$geneName <- ensembl_2_geneName$geneName[ idx ]
head(normalized.counts)

write.table(normalized.counts, file = 'R_output/M23_skin_normalized_counts.csv', qmethod = NULL, sep = ',')
```


# ================== ***** ================== 
# compare between BTWTpaa vs SLMUTpaa
# ================== ***** ================== 
```{r}
## Make comparison between conditions
samples #check treatment
res_BT.SL <- results(dds2, contrast = c("Gavage", "BTWTpaa", "SLMUTpaa") )
head(res_BT.SL)

## Add gene name to res file
rownames(res_BT.SL)<-sub("\\.[0-9]*", "", rownames(res_BT.SL))
idx <- match( rownames(res_BT.SL), ensembl_2_geneName$GENEID )
res_BT.SL$geneName <- ensembl_2_geneName$geneName[ idx ]

## Filter to remove genes with a baseMean of 5 or less
## baseMean is the average expression for that gene across all samples
res_BT.SL.5<-res_BT.SL[res_BT.SL$baseMean>5, ]

## Adjust p-value according to Benjamini & Hochberg method (need to do this since we filtered out genes by base mean 5 above)
res_BT.SL.5$padj <- p.adjust(res_BT.SL.5$pvalue, method="BH")

## Remove lines where pvalue is NA
res_BT.SL.5 <- res_BT.SL.5[!is.na(res_BT.SL.5$pvalue),]



## Check number of differentially expressed genes
as.data.frame(res_BT.SL.5) %>% 
  filter(pvalue < 0.05) %>%
  dim()                       # Number of sig genes by p-value: 1196

as.data.frame(res_BT.SL.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange < 0) %>% 
  dim()  # Number of sig down genes by p-value: 741

as.data.frame(res_BT.SL.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange > 0) %>% 
  dim()  # Number of sig up genes by p-value: 455


res_BT.SL.5_df <- res_BT.SL.5 %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  mutate(sig = ifelse(pvalue < 0.05, "p<0.05", "p.ns")) %>%
  mutate(fdr = ifelse(padj < 0.05, "fdr<0.05", "fdr.ns"))

## Write res.cont DESeq data to output file
write.csv(res_BT.SL.5_df, file="R_output/deseq2_BTvsSL.csv", quote=F, row.names = F)

## Volcano plot
pdf('R_output/BTvsSL_VolcanoPlot.pdf', width = 6, height = 6)
volcanoPlot(res_BT.SL.5) # funciton created below
dev.off()
```

# heatmap
```{r}
# fdr < 0.05
res_BT.SL.5_fdr <- res_BT.SL.5_results %>%
  filter(padj<0.05) %>%
  select("geneName") # 129

res_BT.SL.5_fdr.hm <- res_BT.SL.5_fdr %>%
  left_join(normalized.counts[,c(1:8,24:31)])

res_BT.SL.5_fdr.hm_2 <- data.matrix(res_BT.SL.5_fdr.hm[,2:16])
res_BT.SL.5_fdr.hm_2_scale <- scale(res_BT.SL.5_fdr.hm_2) # scale to center data

res_BT.SL.5_fdr.hm_2_z <- zscore(res_BT.SL.5_fdr.hm_2)

res_BT.SL.5_fdr.hm_2_z <- res_BT.SL.5_fdr.hm_2_z %>%
  as.matrix()

rownames(res_BT.SL.5_fdr.hm_2_z) <- res_BT.SL.5_fdr$geneName
  

# color
myCol <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")))(8)

# try for row annotation log2fc
names(res_BT.SL_KEGG_genes)[names(res_BT.SL_KEGG_genes) == "pathway"] <- "kegg_path"

test_label <- res_BT.SL.5_fdr %>%
  #left_join(res_BT.SL_GSEA_genes[,c(1,10)]) %>% #for hallmark category
  #left_join(res_BT.SL_KEGG_genes[,c(1,10)]) %>% #for kegg category
  left_join(res_BT.SL.5_df[,c(3,8)]) %>% #for log2FC
  column_to_rownames(var = "geneName")

# add geneName to rowName
rownames(res_BT.SL.5_fdr.hm_2_scale) <- res_BT.SL.5_fdr$geneName

res_BT.SL.5_fdr.hm_2_scale <- as.matrix(res_BT.SL.5_fdr.hm_2_scale)



# plot
pdf('R_output/BTvSL_pheatmap_fdr0.05_v3.pdf', width = 5, height = 8)
pheatmap(res_BT.SL.5_fdr.hm_2_scale,
         color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
         #color = myCol, # v2 unmute
         clustering_method = "ward.D2",
         clustering_distance_columns = "correlation",
         clustering_distance_rows = "correlation",
         annotation = treat_ann,
         fontsize_row = 3,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         labels_row = res_BT.SL.5_fdr$geneName,
         scale = "row",
         main = "fdr<0.05_ward.D2 clustering")
dev.off()


## ComplexHeatmap


BT.SL_ann = rowAnnotation(log2FC = anno_barplot(test_label$log2FoldChange, baseline = 0,
                          bar_width = 0.5,
                          gp = gpar(col = ifelse(test_label$log2FoldChange >0, "grey", "black"),
                          fill = ifelse(test_label$log2FoldChange >0, "grey", "black"))),
                          width = unit(2, "cm"))


ann_treat <- data.frame(treat_ann$Gavage[c(1:8,24:30)])
colnames(ann_treat) <- "Gavage"

col_BT.SL.ann <- HeatmapAnnotation(df = ann_treat, which = "col",
                  annotation_width = unit(c(1,2), "cm"), gap = unit(1, "mm"),
                  annotation_name_gp= gpar(fontsize = 5))


# plot
pdf('R_output/BTvSL_Heatmap_fdr0.05.pdf', width = 6, height = 10)
Heatmap(res_BT.SL.5_fdr.hm_2_z,
        height = nrow(res_BT.SL.5_fdr.hm_2_z)*unit(1, "mm"),
        clustering_distance_rows = "pearson",
        col = colorRamp2(c(-2,0,2), c("navy", "white","firebrick3")),
        row_names_gp = grid::gpar(fontsize = 3),
        column_names_gp = grid::gpar(fontsize = 5),
        top_annotation = col_BT.SL.ann,
        right_annotation = BT.SL_ann)
dev.off()
```


# Gene Set analysis
```{r}
# get human homologs names
bm <- getBM(attributes=c("ensembl_gene_id", 
                         "hsapiens_homolog_associated_gene_name"), mart=mart) %>%
  distinct() %>%
  as_tibble() %>%
  na_if("") %>% 
  na.omit() ## since it's not human, use these to get human symbol

bm <- bm %>%
  rename(GENEID = ensembl_gene_id)

res_BT.SL_GSEA <- res_BT.SL %>%
  as.data.frame() %>%
  rownames_to_column("row")

res_BT.SL_GSEA <- inner_join(res_BT.SL_GSEA, bm, by = c("row" = "GENEID"))

res_BT.SL_GSEA <- res_BT.SL_GSEA %>%
  rename(SYMBOL = hsapiens_homolog_associated_gene_name)

#Further, all you’ll care about later on is the gene symbol and the test statistic. Get just those, and remove the NAs. Finally, if you have multiple test statistics for the same symbol, you’ll want to deal with that in some way. Here I’m just averaging them.

res_BT.SL_GSEA_2 <- res_BT.SL_GSEA %>%
  dplyr::select(SYMBOL, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(SYMBOL) %>% 
  summarize(stat=mean(stat))

#The fgsea() function requires a list of gene sets to check, and a named vector of gene-level statistics, where the names should be the same as the gene names in the pathways list. First, let’s create our named vector of test statistics.  deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value.

res_BT.SL_GSEA_ranks <- deframe(res_BT.SL_GSEA_2)
head(res_BT.SL_GSEA_ranks)

#Let’s use the Hallmark gene set from MSigDB. Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying overlaps between gene sets in other MSigDB collections and retaining genes that display coordinate expression. The gmtPathways() function will take a GMT file you downloaded from MSigDB and turn it into a list. Each element in the list is a character vector of genes in the pathway.

# Load the pathways into a named list
pathways.hallmark <- gmtPathways("/home/ml2593/R/MSigDB/h.all.v7.4.symbols.gmt")
# Show the first few pathways, and within those, show only the first few genes. 
pathways.hallmark %>% 
  head() %>% 
  lapply(head)

# Now, run the fgsea algorithm with 1000 permutations:
fgseaRes <- fgseaMultilevel(pathways=pathways.hallmark,
                            stats=res_BT.SL_GSEA_ranks 
                  )
fgseaRes_limit <- fgseaMultilevel(pathways=pathways.hallmark,
                                  stats=res_BT.SL_GSEA_ranks, 
                        minSize=15, maxSize = 500, 
                        eps      = 0.0,
                        nperm=1000
                        )

#Tidy the results:
fgseaResTidy <- fgseaRes %>%
  as_tibble() %>%
  arrange(desc(NES))

# Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

pdf('R_output/BTvSL_gsea.pdf', width = 8, height = 10)
ggplot(fgseaResTidy, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal()
dev.off()


###  filter   ###
fgseaResTidy_filter <- fgseaResTidy %>%
  filter(padj < 0.05) %>%
  mutate(NES_plus = NES>0)

# plot

pdf('R_output/BTvSL_gsea_filter.pdf', width = 8, height = 6)
fgseaResTidy_filter %>%
  as.data.frame() %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "NES_plus",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            legend.title = "Hallmark pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "lightgray", size = 2)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()

# above, bubble plot
pdf('R_output/BTvSL_gsea_filter2.pdf', width = 8, height = 6)
fgseaResTidy_filter %>%
  as.data.frame() %>%
  ggdotchart(x = "pathway", y = "NES",
             color = "NES_plus",
             #palette = c("#00AFBB", "#FC4E07"),
             sorting = "descending",
             add = "segments",
             rotate = TRUE,
             dot.size = 6,
             label = "size",
             font.label = list(color = "white", size = 9,
                               vjust = 0.5),
             ggtheme = theme_pubr())
dev.off()


# flatten list into character for saving as csv
fgseaResTidy$leadingEdge <- vapply(fgseaResTidy$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgseaResTidy, file = 'R_output/BTvSL_hallmark_res.csv', qmethod = NULL, sep = ',')




#What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc.

res_BT.SL_GSEA_genes <- pathways.hallmark %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest(cols = SYMBOL) %>% 
  inner_join(res_BT.SL_GSEA , by="SYMBOL")

write.table(res_BT.SL_GSEA_genes, file = 'R_output/BTvSL_gsea_genesINpathways.csv', qmethod = NULL, sep = ',')

## above table, but only keep the significant ones

res_BT.SL_GSEA_genes_fdr0.05 <- res_BT.SL_GSEA_genes %>%
  filter(padj < 0.05)

write.table(res_BT.SL_GSEA_genes_fdr0.05, file = 'R_output/BTvSL_gsea_genesINpathways_fdr0.05.csv', qmethod = NULL, sep = ',')
```


#above, but try KEGG pathways
```{r}
fgsea_kegg <- fgsea(pathways=gmtPathways("/home/ml2593/R/MSigDB/c2.cp.kegg.v7.4.symbols.gmt"), res_BT.SL_GSEA_ranks, nperm=1000) %>% 
  as_tibble() %>% 
  arrange(padj)

pathways.kegg <- gmtPathways("/home/ml2593/R/MSigDB/c2.cp.kegg.v7.4.symbols.gmt")


# flatten list into character for saving as csv
fgsea_kegg$leadingEdge <- vapply(fgsea_kegg$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgsea_kegg, file = 'R_output/BTvSL_gsea_kegg_ALL.csv', qmethod = NULL, sep = ',')

## 
res_BT.SL_KEGG_genes <- pathways.kegg %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest(cols = SYMBOL) %>% 
  inner_join(res_BT.SL_GSEA , by="SYMBOL")

write.table(res_BT.SL_KEGG_genes, file = 'R_output/BTvSL_gsea_genesINkegg.csv', qmethod = NULL, sep = ',')

# plot- p<0.05
pdf('R_output/BTvSL_gsea_kegg_p0.05.pdf', width = 10, height = 10)
fgsea_kegg %>%
  filter(pval < 0.05) %>%
  mutate(NES_plus = NES>0) %>%
  as.data.frame() %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "NES_plus",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            legend.title = "Kegg pathways NES_BTvsSL",
            ggtheme = theme_minimal()
            ) +
  coord_flip() +
  font("xy.text", size = 5)
dev.off()
```

# above, GO BP 
```{r}
# Load the pathways into a named list
pathways.goBP <- gmtPathways("/home/ml2593/R/MSigDB/c5.go.bp.v7.5.1.symbols.gmt")
# Show the first few pathways, and within those, show only the first few genes. 
pathways.goBP %>% 
  head() %>% 
  lapply(head)

#
fgseaRes_limit7 <- fgsea(pathways=pathways.goBP, 
                         stats=res_BT.SL_GSEA_ranks,
                         eps = 0.0,
                        minSize=15, 
                        maxSize = 500 
                        #nperm=1000
                        )

head(fgseaRes_limit7[order(pval), ])

#Tidy the results:
fgseaResTidy7 <- fgseaRes_limit7 %>%
  as_tibble() %>%
  arrange(desc(NES))



# filter
fgseaResTidy4_filter <- fgseaResTidy7 %>%
  filter(padj < 0.05) %>%
  mutate(NES_plus = NES>0)


## 

pdf('R_output/BTvSL_goBP_0.05.pdf', width = 20, height = 20)
fgseaResTidy7 %>%
  as.data.frame() %>%
  filter(padj < 0.05) %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 Go_BP pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "lightgray", size = 0.3)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()

# enrich in BT
pdf('R_output/BTvSL_goBP_enrichBTWT.pdf', width = 15, height = 10)
fgseaResTidy7 %>%
  as.data.frame() %>%
  filter(padj < 0.05) %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  filter(NES > 0) %>%                   ## enrich in BTWT
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 Go_BP pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "black", size = 5)
            ) +
  theme(axis.text = element_text(size = 1)) +
  theme_minimal() +
  font("xy.text", size = 12, color = "black" 
       #face = "bold"
       ) +
  coord_flip()
dev.off()


# enrich in SLMUT
pdf('R_output/BTvSL_goBP_enrichSLMUT.pdf', width = 15, height = 12)
fgseaResTidy7 %>%
  as.data.frame() %>%
  filter(padj < 0.05) %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  filter(NES < 0) %>%                   ## enrich in SLMUT
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 Go_BP pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "black", size = 5)
            ) +
  theme(axis.text = element_text(size = 1)) +
  theme_minimal() +
  font("xy.text", size = 12, color = "black" 
       #face = "bold"
       ) +
  coord_flip()
dev.off()



# flatten list into character for saving as csv
fgseaResTidy4$leadingEdge <- vapply(fgseaResTidy4$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgseaResTidy4, file = 'R_output/CHOWvPBS_goBP_res.csv', qmethod = NULL, sep = ',')




#What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc.

#$not YET$
```


# ClusterProfiler
```{r}
res_BT.SL %>%
  data.frame() # double check data first

###To perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).

## Create background dataset for hypergeometric testing using all genes tested for significance in the results                 
BT.SL_allOE_genes <- as.character(res_BT.SL.5_df$gene_id)

## Extract significant results
BT.SL_sigOE <- res_BT.SL.5_df %>%
  dplyr::filter(padj < 0.05)
  
BT.SL_sigOE_gene <- as.character(BT.SL_sigOE$gene_id)

## Run GO enrichment analysis 
BT.SL_ego <- enrichGO(gene = BT.SL_sigOE_gene, 
                universe = BT.SL_allOE_genes,
                keyType = "ENSEMBL",
                OrgDb = org.Mm.eg.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                #qvalueCutoff = 0.05, 
                readable = TRUE)

BT.SL_ego.all <- enrichGO(gene = BT.SL_sigOE_gene, 
                universe = BT.SL_allOE_genes,
                keyType = "ENSEMBL",
                OrgDb = org.Mm.eg.db, 
                ont = "ALL", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.1, 
                readable = TRUE)

as.data.frame(BT.SL_ego.all)

## Dotplot 
pdf('R_output/BTvSL_enrichGO.pdf', width = 8, height = 6)
dotplot(BT.SL_ego, showCategory=50)
dev.off()

pdf('R_output/BTvSL_enrichGO_all.pdf', width = 8, height = 12)
dotplot(BT.SL_ego.all, showCategory=50)
dev.off()

## output result table
BT.SL_clusterSum <- data.frame(BT.SL_ego)
write_csv(BT.SL_clusterSum, "R_output/BTvSL_enrichGO_ref.csv" )

BT.SL_clusterSum2 <- data.frame(BT.SL_ego.all)
write_csv(BT.SL_clusterSum2, "R_output/BTvSL_enrichGO_all.csv" )

## upset plot
upsetplot(BT.SL_ego)
```


# Gene-Concept network
```{r}
# Both the barplot() and dotplot() only displayed most significant or selected enriched terms, while users may want to know which genes are involved in these significant terms. 
# In order to consider the potentially biological complexities in which a gene may belong to multiple annotation categories and provide information of numeric changes if available, we developed the cnetplot() function to extract the complex association. 

#The cnetplot() depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network. GSEA result is also supported with only core enriched genes displayed.

## convert gene ID to Symbol
BT.SL_egox <- setReadable(BT.SL_ego, 'org.Mm.eg.db', "ENSEMBL")
BT.SL_egox_genes <- BT.SL_egox[,]

BT.SL_egoAll <- setReadable(BT.SL_ego.all, 'org.Mm.eg.db', "ENSEMBL")
BT.SL_egoAll_genes <- BT.SL_egoAll[,]

# extract genes from each category
BT.SL_geneList <- BT.SL_egox_genes[,c(2,8)] %>%
  mutate(geneID = strsplit(as.character(geneID), "/")) %>%
  unnest(geneID)

colnames(BT.SL_geneList)[2] <- "geneName"


BT.SL_geneList2 <- BT.SL_egoAll_genes[,c(3,9)] %>%
  mutate(geneID = strsplit(as.character(geneID), "/")) %>%
  unnest(geneID)

colnames(BT.SL_geneList2)[2] <- "geneName"

# merge with fold change

BT.SL_geneList <- BT.SL_geneList %>%
  inner_join(res_BT.SL.5_df[,c(3,8)])

BT.SL_geneList.fc <- BT.SL_geneList$log2FoldChange

names(BT.SL_geneList.fc) <- BT.SL_geneList$geneName
BT.SL_geneList.fc <- sort(BT.SL_geneList.fc, decreasing = TRUE)




BT.SL_geneList2 <- BT.SL_geneList2 %>%
  inner_join(res_BT.SL.5_df[,c(3,8)])

BT.SL_geneList2.fc <- BT.SL_geneList2$log2FoldChange

names(BT.SL_geneList2.fc) <- BT.SL_geneList2$geneName
BT.SL_geneList2.fc <- sort(BT.SL_geneList2.fc, decreasing = TRUE)

# plot
pdf('R_output/BTvSL_enrichGO_net.pdf', width = 8, height = 6)
cnetplot(BT.SL_egox, categorySize="pvalue",
         showCategory = 11,
         foldChange=BT.SL_geneList.fc,
         cex_category = 0.5,
         cex_label_category = 0.5,
         cex_label_gene = 0.5
         )
dev.off()


# plot2

pdf('R_output/BTvSL_enrichGO_all_net.pdf', width = 8, height = 10)
options(ggrepel.max.overlaps = Inf)

cnetplot(BT.SL_egoAll,
         showCategory = 21,
         categorySize="pvalue", 
         foldChange=BT.SL_geneList2.fc,
         cex_category = 0.5,
         cex_label_category = 0.5,
         cex_label_gene = 0.5
         #circular = TRUE, colorEdge = TRUE
         )
dev.off()




```




# ================== ***** ================== 
# compare between BTWTpaa vs PBS
# ================== ***** ================== 
```{r}
## Make comparison between conditions
samples #check treatment
res_BT.PBS <- results(dds2, contrast = c("Gavage", "BTWTpaa", "PBS") )
head(res_BT.PBS)

## Add gene name to res file
rownames(res_BT.PBS)<-sub("\\.[0-9]*", "", rownames(res_BT.PBS))
idx2 <- match( rownames(res_BT.PBS), ensembl_2_geneName$GENEID )
res_BT.PBS$geneName <- ensembl_2_geneName$geneName[ idx2 ]

## Filter to remove genes with a baseMean of 5 or less
## baseMean is the average expression for that gene across all samples
res_BT.PBS.5<-res_BT.PBS[res_BT.PBS$baseMean>5, ]

## Adjust p-value according to Benjamini & Hochberg method (need to do this since we filtered out genes by base mean 5 above)
res_BT.PBS.5$padj <- p.adjust(res_BT.PBS.5$pvalue, method="BH")

## Remove lines where pvalue is NA
res_BT.PBS.5 <- res_BT.PBS.5[!is.na(res_BT.PBS.5$pvalue),]



## Check number of differentially expressed genes
as.data.frame(res_BT.PBS.5) %>% 
  filter(pvalue < 0.05) %>%
  dim()                       # Number of sig genes by p-value: 976

as.data.frame(res_BT.PBS.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange < 0) %>% 
  dim()  # Number of sig down genes by p-value: 634

as.data.frame(res_BT.PBS.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange > 0) %>% 
  dim()  # Number of sig up genes by p-value: 342


res_BT.PBS.5_df <- res_BT.PBS.5 %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  mutate(sig = ifelse(pvalue < 0.05, "p<0.05", "p.ns")) %>%
  mutate(fdr = ifelse(padj < 0.05, "fdr<0.05", "fdr.ns"))

## Write res.cont DESeq data to output file
write.csv(res_BT.PBS.5_df, file="R_output/deseq2_BTvsPBS.csv", quote=F, row.names = F)

## Volcano plot
pdf('R_output/BTvsPBS_VolcanoPlot.pdf', width = 6, height = 6)
volcanoPlot(res_BT.PBS.5) # funciton created below
dev.off()
```


# Heatmap
```{r}
# order results table by the smallest adjusted p value:
res_BT.PBS.5_order <- res_BT.PBS.5[order(res_BT.PBS.5$padj),]

res_BT.PBS.5_results = as.data.frame(dplyr::mutate(as.data.frame(res_BT.PBS.5), sig=ifelse(res_BT.PBS.5$padj<0.05, "FDR<0.05", "Not_Sig")), row.names=rownames(res_BT.PBS.5))


# fdr < 0.05
res_BT.PBS.5_fdr <- res_BT.PBS.5_results %>%
  filter(padj<0.05) %>%
  select("geneName") # 109

res_BT.PBS.5_fdr.hm <- res_BT.PBS.5_fdr %>%
  left_join(normalized.counts[,c(1:8,16:23,31)])

res_BT.PBS.5_fdr.hm_2 <- data.matrix(res_BT.PBS.5_fdr.hm[,2:17])
res_BT.PBS.5_fdr.hm_2_scale <- scale(res_BT.PBS.5_fdr.hm_2) # scale to center data

# color
myCol <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")))(8)

#
pdf('R_output/BTvPBS_pheatmap_fdr0.05_v2.pdf', width = 10, height = 15)
pheatmap(res_BT.PBS.5_fdr.hm_2_scale,
         color = myCol, # v2 unmute
         clustering_method = "ward.D2",
         clustering_distance_columns = "correlation",
         clustering_distance_rows = "correlation",
         annotation = treat_ann,
         fontsize_row = 0.5,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         scale = "row",
         main = "fdr<0.05_ward.D2 clustering")
dev.off()


#
pdf('R_output/BTvPBS_pheatmap_fdr0.05_v3.pdf', width = 5, height = 8)
pheatmap(res_BT.PBS.5_fdr.hm_2_scale,
         color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
         clustering_method = "ward.D2",
         clustering_distance_columns = "correlation",
         clustering_distance_rows = "correlation",
         annotation = treat_ann,
         fontsize_row = 3,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         labels_row = res_BT.PBS.5_fdr$geneName,
         scale = "row",
         main = "fdr<0.05_ward.D2 clustering")
dev.off()
```


# gene set testing
```{r}

res_BT.PBS_GSEA <- res_BT.PBS %>%
  as.data.frame() %>%
  rownames_to_column("row")

res_BT.PBS_GSEA <- inner_join(res_BT.PBS_GSEA, bm, by = c("row" = "GENEID"))

res_BT.PBS_GSEA <- res_BT.PBS_GSEA %>%
  rename(SYMBOL = hsapiens_homolog_associated_gene_name)

#Further, all you’ll care about later on is the gene symbol and the test statistic. Get just those, and remove the NAs. Finally, if you have multiple test statistics for the same symbol, you’ll want to deal with that in some way. Here I’m just averaging them.

res_BT.PBS_GSEA_2 <- res_BT.PBS_GSEA %>%
  dplyr::select(SYMBOL, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(SYMBOL) %>% 
  summarize(stat=mean(stat))

#The fgsea() function requires a list of gene sets to check, and a named vector of gene-level statistics, where the names should be the same as the gene names in the pathways list. First, let’s create our named vector of test statistics.  deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value.

res_BT.PBS_GSEA_ranks <- deframe(res_BT.PBS_GSEA_2)
head(res_BT.PBS_GSEA_ranks)



# Now, run the fgsea algorithm with 1000 permutations:
fgseaRes2 <- fgsea(pathways=pathways.hallmark, stats=res_BT.PBS_GSEA_ranks,
                  nperm=1000
                  )
fgseaRes_limit2 <- fgsea(pathways=pathways.hallmark, stats=res_BT.PBS_GSEA_ranks, 
                        minSize=15, maxSize = 500, 
                        nperm=1000
                        )

#Tidy the results:
fgseaResTidy2 <- fgseaRes2 %>%
  as_tibble() %>%
  arrange(desc(NES))

# Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

pdf('R_output/BTvPBS_gsea.pdf', width = 8, height = 10)
ggplot(fgseaResTidy2, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal()
dev.off()


## 
pdf('R_output/BTvPBS_gsea2.pdf', width = 10, height = 10)
ggplot(fgseaResTidy2, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  geom_text(aes(label = format(round(pval,2))))
dev.off()



# flatten list into character for saving as csv
fgseaResTidy2$leadingEdge <- vapply(fgseaResTidy2$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgseaResTidy2, file = 'R_output/BTvPBS_hallmark_res.csv', qmethod = NULL, sep = ',')




#What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc.

res_BT.PBS_GSEA_genes <- pathways.hallmark %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest(cols = SYMBOL) %>% 
  inner_join(res_BT.PBS_GSEA , by="SYMBOL")

write.table(res_BT.PBS_GSEA_genes, file = 'R_output/BTvPBS_gsea_genesINpathways.csv', qmethod = NULL, sep = ',')

```


## ClusterProfiler
```{r}
res_BT.PBS %>%
  data.frame() # double check data first

###To perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).

## Create background dataset for hypergeometric testing using all genes tested for significance in the results                 
BT.PBS_allOE_genes <- as.character(res_BT.PBS.5_df$gene_id)

## Extract significant results
BT.PBS_sigOE <- res_BT.PBS.5_df %>%
  dplyr::filter(padj < 0.05)
  
BT.PBS_sigOE_gene <- as.character(BT.PBS_sigOE$gene_id)

## Run GO enrichment analysis 
BT.PBS_ego <- enrichGO(gene = BT.PBS_sigOE_gene, 
                universe = BT.PBS_allOE_genes,
                keyType = "ENSEMBL",
                OrgDb = org.Mm.eg.db, 
                ont = "BP", 
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                #qvalueCutoff = 0.05, 
                readable = TRUE)

## Dotplot 
pdf('R_output/BTvPBS_enrichGO.pdf', width = 8, height = 6)
dotplot(BT.PBS_ego, showCategory=50)
dev.off()

## output result table
BT.PBS_clusterSum <- data.frame(BT.PBS_ego)
write_csv(BT.PBS_clusterSum, "R_output/BTvPBS_enrichGO_ref.csv" )
```


# Gene-Concept network
```{r}
# Both the barplot() and dotplot() only displayed most significant or selected enriched terms, while users may want to know which genes are involved in these significant terms. 
# In order to consider the potentially biological complexities in which a gene may belong to multiple annotation categories and provide information of numeric changes if available, we developed the cnetplot() function to extract the complex association. 

#The cnetplot() depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network. GSEA result is also supported with only core enriched genes displayed.

## convert gene ID to Symbol
BT.PBS_egox <- setReadable(BT.PBS_ego, 'org.Mm.eg.db', "ENSEMBL")
BT.PBS_egox_genes <- BT.PBS_egox [,]

# extract genes from each category
BT.PBS_geneList <- BT.PBS_egox_genes[,c(2,8)] %>%
  mutate(geneID = strsplit(as.character(geneID), "/")) %>%
  unnest(geneID)

colnames(BT.PBS_geneList)[2] <- "geneName"

# merge with fold change

BT.PBS_geneList <- BT.PBS_geneList %>%
  inner_join(res_BT.PBS.5_df[,c(3,8)])

BT.PBS_geneList.fc <- BT.PBS_geneList$log2FoldChange

names(BT.PBS_geneList.fc) <- BT.PBS_geneList$geneName
BT.PBS_geneList.fc <- sort(BT.PBS_geneList.fc, decreasing = TRUE)

# plot
pdf('R_output/BTvPBS_enrichGO_net.pdf', width = 8, height = 6)
cnetplot(BT.PBS_egox, categorySize="pvalue", 
         foldChange=BT.PBS_geneList.fc,
         cex_category = 0.5)
dev.off()

```



# ================== ***** ================== 
# compare between CHOW vs PBS
# ================== ***** ================== 
```{r}
## Make comparison between conditions
samples #check treatment
res_chow.pbs <- results(dds2, contrast = c("Gavage", "no", "PBS") )
head(res_chow.pbs)

## Add gene name to res file
rownames(res_chow.pbs)<-sub("\\.[0-9]*", "", rownames(res_chow.pbs))
idx3 <- match( rownames(res_chow.pbs), ensembl_2_geneName$GENEID )
res_chow.pbs$geneName <- ensembl_2_geneName$geneName[ idx3 ]

## Filter to remove genes with a baseMean of 5 or less
## baseMean is the average expression for that gene across all samples
res_chow.pbs.5<-res_chow.pbs[res_chow.pbs$baseMean>5, ]

## Adjust p-value according to Benjamini & Hochberg method (need to do this since we filtered out genes by base mean 5 above)
res_chow.pbs.5$padj <- p.adjust(res_chow.pbs.5$pvalue, method="BH")

## Remove lines where pvalue is NA
res_chow.pbs.5 <- res_chow.pbs.5[!is.na(res_chow.pbs.5$pvalue),]



## Check number of differentially expressed genes
as.data.frame(res_chow.pbs.5) %>% 
  filter(pvalue < 0.05) %>%
  dim()                       # Number of sig genes by p-value: 1776

as.data.frame(res_chow.pbs.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange < 0) %>% 
  dim()  # Number of sig down genes by p-value: 1064

as.data.frame(res_chow.pbs.5) %>% 
  filter(pvalue < 0.05 & log2FoldChange > 0) %>% 
  dim()  # Number of sig up genes by p-value: 712


res_chow.pbs.5_df <- res_chow.pbs.5 %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  mutate(sig = ifelse(pvalue < 0.05, "p<0.05", "p.ns")) %>%
  mutate(fdr = ifelse(padj < 0.05, "fdr<0.05", "fdr.ns"))

## Write res.cont DESeq data to output file
write.csv(res_chow.pbs.5_df, file="R_output/deseq2_CHOWvsPBS.csv", quote=F, row.names = F)

## Volcano plot
pdf('R_output/CHOWvsPBS_VolcanoPlot.pdf', width = 6, height = 6)
volcanoPlot(res_chow.pbs.5) # funciton created below
dev.off()
```


# heatmap
```{r}
# order results table by the smallest adjusted p value:
res_chow.pbs.5_order <- res_chow.pbs.5[order(res_chow.pbs.5$padj),]

res_chow.pbs.5_results = as.data.frame(dplyr::mutate(as.data.frame(res_chow.pbs.5), sig=ifelse(res_chow.pbs.5$padj<0.05, "FDR<0.05", "Not_Sig")), row.names=rownames(res_chow.pbs.5))

# fdr < 0.05
res_chow.pbs.5_fdr <- res_chow.pbs.5_results %>%
  filter(padj<0.05) %>%
  select("geneName") # 354

res_chow.pbs.5_fdr.hm <- res_chow.pbs.5_fdr %>%
  left_join(normalized.counts[,c(9:23,31)])

res_chow.pbs.5_fdr.hm_2 <- data.matrix(res_chow.pbs.5_fdr.hm[,2:16])
res_chow.pbs.5_fdr.hm_2_scale <- scale(res_chow.pbs.5_fdr.hm_2) # scale to center data

# try remove chow 22, 12
res_chow.pbs.5_fdr.hm_2_scale2 <- scale(res_chow.pbs.5_fdr.hm_2[,c(1,3:5,7:15)])

#
pdf('R_output/CHOWvPBS_pheatmap_fdr0.05.pdf', width = 5, height = 8)
pheatmap(res_chow.pbs.5_fdr.hm_2_scale,
         color = colorRampPalette(c("navy", "white", "firebrick3"))(100),
         #color = myCol, # v2 unmute
         clustering_method = "ward.D2",
         clustering_distance_columns = "correlation",
         clustering_distance_rows = "correlation",
         annotation = treat_ann,
         fontsize_row = 3,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         labels_row = res_chow.pbs.5_fdr$geneName,
         scale = "row",
         main = "fdr<0.05_ward.D2 clustering")
dev.off()



#####
res_chow.pbs.5_fdr.hm_2_z <- zscore(res_chow.pbs.5_fdr.hm_2)

res_chow.pbs.5_fdr.hm_2_z <- res_chow.pbs.5_fdr.hm_2_z%>%
  as.matrix()

rownames(res_chow.pbs.5_fdr.hm_2_z) <- res_chow.pbs.5_fdr.hm$geneName


test_label2 <- res_chow.pbs.5_fdr.hm %>%
  left_join(res_chow.pbs.5_df[,c(3,8)]) #for log2FC

rownames(test_label2) <- test_label2$geneName
test_label2 <- test_label2[-354,]




#### complexheatmap #####

CHOW.PBS_ann = rowAnnotation(log2FC = anno_barplot(test_label2$log2FoldChange, baseline = 0,
                          bar_width = 0.5,
                          gp = gpar(col = ifelse(test_label2$log2FoldChange >0, "grey", "black"),
                          fill = ifelse(test_label2$log2FoldChange >0, "grey", "black"))),
                          width = unit(2, "cm"))


ann_treat2 <- data.frame(treat_ann$Gavage[c(9:23)])
colnames(ann_treat2) <- "Gavage"

col_CHOW.PBS.ann <- HeatmapAnnotation(df = ann_treat2, which = "col",
                  annotation_width = unit(c(1,2), "cm"), gap = unit(1, "mm"),
                  annotation_name_gp= gpar(fontsize = 5))



pdf('R_output/CHOWvPBS_Heatmap_fdr0.05.pdf', width = 6, height = 20)
Heatmap(res_chow.pbs.5_fdr.hm_2_z,
        height = nrow(res_chow.pbs.5_fdr.hm_2_z)*unit(1, "mm"),
        clustering_distance_rows = "pearson",
        col = colorRamp2(c(-2,0,2), c("navy", "white","firebrick3")),
        row_names_gp = grid::gpar(fontsize = 3),
        column_names_gp = grid::gpar(fontsize = 5),
        top_annotation = col_CHOW.PBS.ann,
        right_annotation = CHOW.PBS_ann)
dev.off()

# check NA presence
giveNAs = which(is.na(as.matrix(dist(res_chow.pbs.5_fdr.hm_2_z))),arr.ind=TRUE)
head(giveNAs)

tab = sort(table(c(giveNAs)),decreasing=TRUE)
checkNA = sapply(1:length(tab),function(i){
sum(is.na(as.matrix(dist(res_chow.pbs.5_fdr.hm_2_z[-as.numeric(names(tab[1:i])),]))))
})
rmv = names(tab)[1:min(which(checkNA==0))]

res_chow.pbs.5_fdr.hm_2_z = res_chow.pbs.5_fdr.hm_2_z[-as.numeric(rmv),]
```

# gene set testing
```{r}
res_chow.pbs_GSEA <- res_chow.pbs %>%
  as.data.frame() %>%
  rownames_to_column("row")

res_chow.pbs_GSEA <- inner_join(res_chow.pbs_GSEA, bm, by = c("row" = "GENEID"))

res_chow.pbs_GSEA <- res_chow.pbs_GSEA %>%
  rename(SYMBOL = hsapiens_homolog_associated_gene_name)

#Further, all you’ll care about later on is the gene symbol and the test statistic. Get just those, and remove the NAs. Finally, if you have multiple test statistics for the same symbol, you’ll want to deal with that in some way. Here I’m just averaging them.

res_chow.pbs_GSEA_2 <- res_chow.pbs_GSEA %>%
  dplyr::select(SYMBOL, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(SYMBOL) %>% 
  summarize(stat=mean(stat))

#The fgsea() function requires a list of gene sets to check, and a named vector of gene-level statistics, where the names should be the same as the gene names in the pathways list. First, let’s create our named vector of test statistics.  deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value.

res_chow.pbs_GSEA_ranks <- deframe(res_chow.pbs_GSEA_2)

#Let’s use the Hallmark gene set from MSigDB. Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying overlaps between gene sets in other MSigDB collections and retaining genes that display coordinate expression. The gmtPathways() function will take a GMT file you downloaded from MSigDB and turn it into a list. Each element in the list is a character vector of genes in the pathway.

# Load the pathways into a named list
pathways.hallmark <- gmtPathways("/home/ml2593/R/MSigDB/h.all.v7.4.symbols.gmt")
# Show the first few pathways, and within those, show only the first few genes. 
pathways.hallmark %>% 
  head() %>% 
  lapply(head)

# Now, run the fgsea algorithm with 1000 permutations:
fgseaRes3 <- fgseaMultilevel(pathways=pathways.hallmark, stats=res_chow.pbs_GSEA_ranks 
                  #nperm=1000
                  )
fgseaRes_limit3 <- fgseaMultilevel(pathways=pathways.hallmark, stats=res_chow.pbs_GSEA_ranks, 
                        minSize=15, maxSize = 500, 
                        #nperm=1000
                        )

#Tidy the results:
fgseaResTidy3 <- fgseaRes3 %>%
  as_tibble() %>%
  arrange(desc(NES))

# Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

pdf('R_output/CHOWvPBS_gsea.pdf', width = 8, height = 10)
ggplot(fgseaResTidy3, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=padj<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal()
dev.off()



# flatten list into character for saving as csv
fgseaResTidy3$leadingEdge <- vapply(fgseaResTidy3$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgseaResTidy3, file = 'R_output/CHOWvPBS_hallmark_res.csv', qmethod = NULL, sep = ',')




#What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc.

res_chow.pbs_GSEA_genes <- pathways.hallmark %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest(cols = SYMBOL) %>% 
  inner_join(res_chow.pbs_GSEA , by="SYMBOL")

write.table(res_chow.pbs_GSEA_genes, file = 'R_output/CHOWvPBS_gsea_genesINpathways.csv', qmethod = NULL, sep = ',')
```


#above, but KEGG pathways
```{r}
fgsea_kegg3 <- fgsea(pathways=gmtPathways("/home/ml2593/R/MSigDB/c2.cp.kegg.v7.4.symbols.gmt"), res_chow.pbs_GSEA_ranks, nperm=1000) %>% 
  as_tibble() %>% 
  arrange(padj)

pathways.kegg <- gmtPathways("/home/ml2593/R/MSigDB/c2.cp.kegg.v7.4.symbols.gmt")


# flatten list into character for saving as csv
fgsea_kegg3 $leadingEdge <- vapply(fgsea_kegg3 $leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgsea_kegg3 , file = 'R_output/CHOWvPBS_gsea_kegg_ALL.csv', qmethod = NULL, sep = ',')

## 
res_chow.pbs_KEGG_genes <- pathways.kegg %>% 
  enframe("pathway", "SYMBOL") %>% 
  unnest(cols = SYMBOL) %>% 
  inner_join(res_chow.pbs_GSEA , by="SYMBOL")

write.table(res_chow.pbs_KEGG_genes, file = 'R_output/CHOWvPBS_gsea_genesINkegg.csv', qmethod = NULL, sep = ',')

# plot- p<0.05
pdf('R_output/CHOWvPBS_gsea_kegg_p0.05.pdf', width = 10, height = 10)
fgsea_kegg3 %>%
  filter(pval < 0.05) %>%
  mutate(NES_plus = NES>0) %>%
  as.data.frame() %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "NES_plus",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            legend.title = "Kegg pathways NES_CHOWvsPBS",
            ggtheme = theme_minimal()
            ) +
  coord_flip() +
  font("xy.text", size = 5)
dev.off()
```


# above, GO BP 
```{r}

#Let’s use the Hallmark gene set from MSigDB. Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying overlaps between gene sets in other MSigDB collections and retaining genes that display coordinate expression. The gmtPathways() function will take a GMT file you downloaded from MSigDB and turn it into a list. Each element in the list is a character vector of genes in the pathway.

# Load the pathways into a named list
pathways.goBP <- gmtPathways("/home/ml2593/R/MSigDB/c5.go.bp.v7.5.1.symbols.gmt")
# Show the first few pathways, and within those, show only the first few genes. 
pathways.goBP %>% 
  head() %>% 
  lapply(head)

# Now, run the fgsea algorithm with 1000 permutations:
#fgseaRes4 <- fgsea(pathways=pathways.goBP, stats=res_chow.pbs_GSEA_ranks,
 #                 nperm=1000
  #                )
fgseaRes_limit4 <- fgsea(pathways=pathways.goBP, 
                         stats=res_chow.pbs_GSEA_ranks,
                         eps = 0.0,
                        minSize=15, 
                        maxSize = 500 
                        #nperm=1000
                        )

head(fgseaRes_limit4[order(pval), ])

#Tidy the results:
fgseaResTidy4 <- fgseaRes_limit4 %>%
  as_tibble() %>%
  arrange(desc(NES))


# filter
fgseaResTidy4_filter <- fgseaResTidy4 %>%
  filter(padj < 0.05) %>%
  mutate(NES_plus = NES>0)


## 

pdf('R_output/CHOWvPBS_goBP_0.05.pdf', width = 20, height = 20)
fgseaResTidy4_filter %>%
  as.data.frame() %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "NES_plus",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            legend.title = "C5 Go_BP pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "lightgray", size = 0.3)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()

# enrich in PBS
pdf('R_output/CHOWvPBS_goBP_enrichPBS.pdf', width = 20, height = 20)
fgseaResTidy4_filter %>%
  as.data.frame() %>%
  filter(NES <0) %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 Go_BP pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "black", size = 0.3)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()






# flatten list into character for saving as csv
fgseaResTidy4$leadingEdge <- vapply(fgseaResTidy4$leadingEdge, paste, collapse = ", ", character(1L))

write.table(fgseaResTidy4, file = 'R_output/CHOWvPBS_goBP_res.csv', qmethod = NULL, sep = ',')




#What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc.

#$not YET$
```

# immunologic signature gene sets
```{r}
# Load the pathways into a named list
pathways.immuneALL <- gmtPathways("/home/ml2593/R/MSigDB/c7.all.v7.5.1.symbols.gmt")
pathways.immuneSIG <- gmtPathways("/home/ml2593/R/MSigDB/c7.immunesigdb.v7.5.1.symbols.gmt")
# Show the first few pathways, and within those, show only the first few genes. 
pathways.immuneALL %>% 
  head() %>% 
  lapply(head)

pathways.immuneSIG %>% 
  head() %>% 
  lapply(head)

# Now, run the fgsea algorithm with 1000 permutations:
#fgseaRes4 <- fgsea(pathways=pathways.goBP, stats=res_chow.pbs_GSEA_ranks,
 #                 nperm=1000
  #                )
fgseaRes_limit5 <- fgsea(pathways= pathways.immuneALL, 
                         stats=res_chow.pbs_GSEA_ranks,
                         eps = 0.0,
                        minSize=15, 
                        maxSize = 500 
                        #nperm=1000
                        )

head(fgseaRes_limit5[order(pval), ])


fgseaRes_limit6 <- fgsea(pathways= pathways.immuneSIG, 
                         stats=res_chow.pbs_GSEA_ranks,
                         eps = 0.0,
                        minSize=15, 
                        maxSize = 500 
                        #nperm=1000
                        )


#Tidy the results:
fgseaResTidy6 <- fgseaRes_limit6 %>%
  as_tibble() %>%
  arrange(desc(NES))


# filter
fgseaResTidy6_filter <- fgseaResTidy6 %>%
  filter(padj < 0.05) %>%
  mutate(NES_plus = NES>0)


## 

pdf('R_output/CHOWvPBS_immuneALL_0.05.pdf', width = 20, height = 20)
fgseaResTidy5_filter %>%
  as.data.frame() %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 immune pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "lightgray", size = 0.3)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()

## immune sigDB
pdf('R_output/CHOWvPBS_immuneSIG_0.05.pdf', width = 20, height = 20)
fgseaResTidy6_filter %>%
  as.data.frame() %>%
  mutate(padjBELOW0.01 = padj<0.01) %>%
  ggbarplot(x = "pathway", y = "NES",
            fill = "padjBELOW0.01",
            color = "white",
            palette = c("#00AFBB", "#FC4E07"),
            sort.val = "asc",
            sort.by.groups = FALSE,
            ylab = "Normalized Enrichment Score (NES)",
            xlab = "Pathway",
            #legend.title = "C5 immune pathways NES from GSEA",
            #ggtheme = theme_minimal()
            add = "segments",
            add.params = list(color = "lightgray", size = 0.3)
            ) +
  theme(axis.text = element_text(size = 0.3)) +
  theme_minimal() +
  coord_flip()
dev.off()
```

# ClusterProfiler
```{r}
res_chow.pbs %>%
  data.frame() # double check data first

###To perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).

## Create background dataset for hypergeometric testing using all genes tested for significance in the results                 
chow.pbs_allOE_genes <- as.character(res_chow.pbs.5_df$gene_id)

## Extract significant results
chow.pbs_sigOE <- res_chow.pbs.5_df %>%
  dplyr::filter(padj < 0.05)
  
chow.pbs_sigOE_gene <- as.character(chow.pbs_sigOE$gene_id)

## Run GO enrichment analysis 
chow.pbs_ego <- enrichGO(gene = chow.pbs_sigOE_gene, 
                universe = chow.pbs_allOE_genes,
                keyType = "ENSEMBL",
                OrgDb = org.Mm.eg.db, 
                ont = "BP", 
                pAdjustMethod = "BH",
                pvalueCutoff = 0.05,
                #qvalueCutoff = 0.05, 
                readable = TRUE)

## Dotplot 
pdf('R_output/CHOWvPBS_enrichGO.pdf', width = 8, height = 12)
dotplot(chow.pbs_ego, showCategory=50) 
dev.off()

## output result table
chow.pbs_clusterSum <- data.frame(chow.pbs_ego)
write_csv(chow.pbs_clusterSum, "R_output/CHOWvPBS_enrichGO_ref.csv" )
```

# Gene-Concept network
```{r}
# Both the barplot() and dotplot() only displayed most significant or selected enriched terms, while users may want to know which genes are involved in these significant terms. 
# In order to consider the potentially biological complexities in which a gene may belong to multiple annotation categories and provide information of numeric changes if available, we developed the cnetplot() function to extract the complex association. 

#The cnetplot() depicts the linkages of genes and biological concepts (e.g. GO terms or KEGG pathways) as a network. GSEA result is also supported with only core enriched genes displayed.

## convert gene ID to Symbol
chow.pbs_egox <- setReadable(chow.pbs_ego, 'org.Mm.eg.db', "ENSEMBL")
chow.pbs_egox_genes <- chow.pbs_egox [,]

# extract genes from each category
chow.pbs_geneList <- chow.pbs_egox_genes[,c(2,8)] %>%
  mutate(geneID = strsplit(as.character(geneID), "/")) %>%
  unnest(geneID)

colnames(chow.pbs_geneList)[2] <- "geneName"

# merge with fold change

chow.pbs_geneList <- chow.pbs_geneList %>%
  inner_join(res_chow.pbs.5_df[,c(3,8)])

chow.pbs_geneList.fc <- chow.pbs_geneList$log2FoldChange

names(chow.pbs_geneList.fc) <- chow.pbs_geneList$geneName
chow.pbs_geneList.fc <- sort(chow.pbs_geneList.fc, decreasing = TRUE)

# plot
pdf('R_output/CHOWvPBS_enrichGO_net.pdf', width = 8, height = 6)
cnetplot(chow.pbs_egox, categorySize="pvalue",
         #showCategory = 5,
         foldChange=chow.pbs_geneList.fc,
         cex_category = 0.5)
dev.off()

# plot2 50?
cnetplot(chow.pbs_egox, 
         categorySize="pvalue",
         showCategory = 50,
         foldChange=chow.pbs_geneList.fc,
         node_label = "category",
         cex_category = 0.5,
         cex_label_category = 0.5
         #circular = TRUE
         )

upsetplot(chow.pbs_egox)

```

# ================== ***** ================== 
# compare between SLMUTpaa vs PBS
# ================== ***** ================== 
```{r}
## Make comparison between conditions
samples #check treatment
res_SL.PBS <- results(dds2, contrast = c("Gavage", "SLMUTpaa", "PBS") )
head(res_SL.PBS)

## Add gene name to res file
rownames(res_SL.PBS)<-sub("\\.[0-9]*", "", rownames(res_SL.PBS))
idx4 <- match( rownames(res_SL.PBS), ensembl_2_geneName$GENEID )
res_SL.PBS$geneName <- ensembl_2_geneName$geneName[ idx4 ]

## Filter to remove genes with a baseMean of 5 or less
## baseMean is the average expression for that gene across all samples
res_SL.PBS.5<-res_SL.PBS[res_SL.PBS$baseMean>5, ]

## Adjust p-value according to Benjamini & Hochberg method (need to do this since we filtered out genes by base mean 5 above)
res_SL.PBS.5$padj <- p.adjust(res_SL.PBS.5$pvalue, method="BH")

## Remove lines where pvalue is NA
res_SL.PBS.5 <- res_SL.PBS.5[!is.na(res_SL.PBS.5$pvalue),]



## Check number of differentially expressed genes
as.data.frame(res_SL.PBS.5) %>% 
  dplyr::filter(pvalue < 0.05) %>%
  dim()                       # Number of sig genes by p-value: 1450

as.data.frame(res_SL.PBS.5) %>% 
  dplyr::filter(pvalue < 0.05 & log2FoldChange < 0) %>% 
  dim()  # Number of sig down genes by p-value: 814

as.data.frame(res_SL.PBS.5) %>% 
  dplyr::filter(pvalue < 0.05 & log2FoldChange > 0) %>% 
  dim()  # Number of sig up genes by p-value: 636


res_SL.PBS.5_df <- res_SL.PBS.5 %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  mutate(sig = ifelse(pvalue < 0.05, "p<0.05", "p.ns")) %>%
  mutate(fdr = ifelse(padj < 0.05, "fdr<0.05", "fdr.ns"))
```



